## Part 1: Installing
1.1. Making a project- choose a dir then type "django-admin startproject
{project name.let's use (mysite)}"

1.2. Making an app- python3 manage.py startapp {name. lets use (polls)}.

adittional: (Making a simple message 'hello world')
1.3. Go to polls/views.py and type:
from django.http import HttpResponse

def func1(request):
    return HttpResponse('hello world')

1.4. Make a file urls.py at polls and type:
from django.urls import path
from . import views

urlpatterns = [
    path('helloworld/',views.func1)
]

1.5. In mysite/urls.py, follow the ff. for URLConf/URL Configuration

## Part 2: Database setting up, creating first model, and a quick intro to
Django’s automatically-generated admin site
2.1. Database Setup
- Head to the mysite/settings.py and as you notice it is full of module-level
stuffs. 

2.1.1. Database dictionary- Django has installed database already which is SQLite.
But you can change your db if you want, other db like mySQL, oracle, etc.
As if you notice the DATABASE dict, it contains 2 items:
* ENGINE (depends what backend and db you are using)
* NAME (contains full path (including filename). The default val contains 
BASE_DIR / 'db.sqlite3' will store that file in project dir)

2.1.2. Set the TIME_ZONE on your timezone

2.1.3. INSTALLED_APPS- it has all the app names. It has default apps which is
listed because of the common cases.

2.1.4. Migrating- to migrate, type 'python3 manage.py migrate'. It creates a 
necessary db tables based on apps present at INSTALLED_APPS and writes
them in your backend/db.

2.2. Creating Models
Model.py- contains fields(models) and characteristics of your data stored

2.2.1 Fields(classes)- represented  by every instance inside.
- in our example like the Question field, we have instances;
*question_text- contains models.CharField(maxlength=200), is for character fields
*pub_date- contains models.DateTimeField('date published'), is for datetimes

- On Choices field, we have a ForeignKey() which is to identify relationship
between two fields/classes. Thats why it contains Question class as its
parameter. Its 2nd parameter is 'on_delete = models.CASCADE' means if we 
delete item/s in Question, we also delete its data in Choices

2.3. Activating Models
2.3.1. Django apps can be use in different django projects just make sure they
are listed on INSTALLED_APPS at inner django project folder/settings.py.
Just type the dir of apps upto class inside the apps.py.
Format: {dj dir}.apps.{class name} EX: polls.apps.PollsConfig

- After listing it run the code: "python3 manage.py makemigrations polls" to
declare to django that you make some changes on your models (also your database
schema) and you want to save the changes on disk(through migration).

2.3.2. polls/migrations/0001_initial.py saves the migrations that happened.
They are editable, incase you want to modify something

2.3.3. command "python3 manage.py sqlmigration polls 0001": takes migration
names and returns their SQL

Note the following:
- The exact output will vary depending on the database you are using. The
example above is generated for PostgreSQL.
- Table names are automatically generated by combining the name of the app
(polls) and the lowercase name of the model – question and choice. (You can override this behavior.)

- Primary keys (IDs) are added automatically. (You can override this, too.)

- By convention, Django appends "_id" to the foreign key field name. (Yes,
you can override this, as well.)

- The foreign key relationship is made explicit by a FOREIGN KEY constraint. Don’t worry about the DEFERRABLE parts; it’s telling PostgreSQL to not enforce the foreign key until the end of the transaction.

- It’s tailored to the database you’re using, so database-specific field
types such as auto_increment (MySQL), serial (PostgreSQL), or integer primary key autoincrement (SQLite) are handled for you automatically. Same goes for the quoting of field names – e.g., using double quotes or single quotes.

- The sqlmigrate command doesn’t actually run the migration on your db - instead,
it prints it to the screen so that you can see what SQL Django
thinks is required. It’s useful for checking what Django is going to do or
if you have database administrators who require SQL scripts for changes.

2.3.4. python manage.py check; this checks for any problems in your project
without making migrations or touching the database.


2.3.5. 3 steps in making model changes
- Change your models (in models.py).
- 'python manage.py makemigrations' to create migrations for those changes
- 'python manage.py migrate' to apply those changes to the database.

* Migrations are very powerful and let you change your models over time, as
you develop your project, without the need to delete your database or tables
and make new ones - it specializes in upgrading your database live, without
losing data.

2.4. Writing and Saving in Database
2.4.1. Open iPython for manage.py via: python3 manage.py shell.

2.4.2. Import your models: from main.models import ToDoList,Items.

2.4.3. Adding data in database is just easy. Lets try adding some data: 
t = ToDoList(name="Michael's Studies"). To save it, simply add: t.save().

2.4.4. ToDoList.objects.all(): To see all your object, run.

2.4.5. ToDoList.objects.get(id={object id}): To get a specific data using id.

2.4.6. ToDoList.objects.get(name='{word}'): to search via name.

2.4.7. To show its items from relative class:
format: t.{relative class name}_set.all()
ex: t.items_set.all()

2.4.8. To add items in todolist at t, you must use t.items_set.create(follow the
patterns(give what the instances onto they need)).
Ex: t.items_set.create(text='Finish django',complete=False)

2.4.9. If you already exit the iPython and you want to access the db inside it,
just import again what we import before to access this db.

## Part 3: User Interface (UI)
3.1. The 'URLConf' maps the 'urlpatterns' to views(templates)

3.2. Raising 404- if you enter something that can't be found, the Http404 will
raise automatically. If you want to still type it, just append ff in your
function were you need it:
--from django.http import Http404
-and when you want to use it, specially on if/try statements, just:
--raise Http404("message")

-But you can simply write:
question = get_object_or_404(Question, pk=question_id)

-Instead of writing ehole try statement:
try:
    myquestion = question.objects.get(pk=question_id)
except question.DoesNotExist:
    raise Http404("Question does not exist")

-Just import:
from django.shortcuts import get_object_or_404, render

3.3. Removing hardcoded URLs in templates
-Instead of doing this tightly-coupled URLs;
<li><a href="/polls/{{ question.id }}/">{{ question.question_text }}</a></li>

-Python allows us to do this:
<li><a href="{% url 'detail' question.id %}">{{ question.question_text }}</a></li>

-As you notice, we use 'detail' instead of URL. It is possible since we
claim it in our urls.py when we add name for detail() and detail.html:

# the 'name' value as called by the {% url %} template tag
path('<int:question_id>/', views.detail, name='detail'),

-We already declaire its link in urls.py. The a tag head to urls.py because we
put 'url' inside the value of a tag's href so call the detail() by its name.

-If you want to change the URL of the polls detail view to something else,
perhaps to something like polls/specifics/12/ instead of doing it in the
template (or templates) you would change it in polls/urls.py:
...
# added the word 'specifics'
path('specifics/<int:question_id>/', views.detail, name='detail'),
...

3.4. Namespacing URL names and Why?
- We namespace URL names(paths urlpatterns) incase we had the same function
name in other app installed so the will not be confused on what function/URL
to access.
Before:
from django.urls import path
from . import views

urlpatterns = [
    path('', views.index, name='index'),
    path('<int:question_id>/', views.detail, name='detail'),
    path('<int:question_id>/results/', views.results, name='results'),
    path('<int:question_id>/vote/', views.vote, name='vote'),
]

After:
from django.urls import path
from . import views

app_name = 'polls'  # ADDED LINE
urlpatterns = [
    path('', views.index, name='index'),
    path('<int:question_id>/', views.detail, name='detail'),
    path('<int:question_id>/results/', views.results, name='results'),
    path('<int:question_id>/vote/', views.vote, name='vote'),
]

-Now change your polls/index.html template from:
polls/templates/polls/index.html

Before:
<li><a href="{% url 'detail' question.id %}">{{ question.question_text }}</a></li>

to point at the namespaced detail view:
After:
<li><a href="{% url 'polls:detail' question.id %}">{{ question.question_text }}</a></li>


## Part 3: Form processing and Cutting down our code
3.1. Edit the detail.html
Before:
{% extends 'polls/base.html' %}

{% block title %}Questions{% endblock %}

{% block content %}
<h1>{{ question.question_text }}</h1>
<ul>
{% for choice in question.choice_set.all %}
    <li>{{ choice.choice_text }}</li>
{% endfor %}
</ul>
{% endblock %}

After:
{% extends 'polls/base.html' %}

{% block title %}Questions{% endblock %}

{% block content %}
<form action="{% url 'polls:vote' question.id %}" method="post">
{% csrf_token %}
<fieldset>
    <legend><h1>{{ question.question_text }}</h1></legend>
    {% if error_message %}
        <p><strong>{{ error_message }}</strong></p>
    {% endif %}
    {% for choice in question.choice_set.all %}
        <!-- for the radio button(checkbox) -->
        <!-- for loop.counter counts the for loop iteration -->
        <input type="radio" name="choice" id="choice{{ forloop.counter }}" value="{{ choice.id }}">
        <!-- for the choice text -->
        <label for="choice{{ forloop.counter }}">
            {{ choice.choice_text }}
        </label><br>
    {% endfor %}
</fieldset>
<input type="submit" value="Vote">
</form>
{% endblock %}

3.2. Analyzing our tags:
a. <fieldset> -another way of grouping related elements
b. <legend> -regularly used for highlighting the main ideas
c. <strong> -text inside this should not be ignored
d. <input> -for radio button
e. <label> -for choice text
f. {{forloop.counter}} -counts the for loop iteration. We used it here to number our choices

-What is and Why we use is {{csrf_token}}/(Cross Site Request Forgery token)?
---This token is required to post/get data back to the server. The csrf token expires when the
authenticated user is logged out.

--used to verify that the authenticated user is the person actually making the requests to
the application.


3.3. Making votes:
-Edit the vote():
from django.urls import reverse
#--
def vote(request, question_id):
    question = get_object_or_404(Question, pk=question_id)
    try:
        selected_choice = question.choice_set.get(pk=request.POST['choice'])
    except (KeyError, Choice.DoesNotExist):
        # Redisplay the question voting form.
        return render(request, 'polls/detail.html', {
            'question': question,
            'error_message': "You didn't select a choice.",
        })
    else:
        selected_choice.votes += 1
        selected_choice.save()
        # Always return an HttpResponseRedirect after successfully dealing
        # with POST data. This prevents data from being posted twice if a
        # user hits the Back button.
        return HttpResponseRedirect(reverse('polls:results', args=(question.id,)))

-request.POST is a dictionary-like object that lets you access submitted
data by key name. In this case, request.POST['choice'] returns the ID of the
selected choice, as a string. request.POST values are always strings.

-request.POST['choice'] will raise KeyError if choice wasn’t provided in
POST data. The above code checks for KeyError and redisplays the question
form with an error message if choice isn’t given.

-HttpResponseRedirect takes a single argument: the URL to which the user will be
redirectedHttp ResponseRedirect takes a single argument: the URL to which the user
will be redirected. 

-We are using the reverse() function in the HttpResponseRedirect constructor
in this example. This function helps avoid having to hardcode a URL in
the view function. It is given the name of the view that we want to pass
control to and the variable portion of the URL pattern that points to that
view. In this case, using the URLconf we set up in Tutorial 3, this reverse()
call will return a string like: '/polls/3/results/'
where the 3 is the value of question.id. This redirected URL will then
call the 'results' view to display the final page.


3.4. ### HOW DOES THE CODE RUNS ###
*URL/polls/
- From the urlpatterns, the path call the index() and it renders the index.html.
Inside the index.html, it prints at the screen all the question from the
latest_question_list which is an o-bject from index(). In there, we declare
its value as the 5 last questions. So in index.html, we are returning 5
questions if we have 5 or more questions, else, how many it has. And if you
press any of those, it will direct you to that question and its choices because
each of them contains id. Id that directs to you to any of them.

*URL/polls/{{question.id}}
- After clicking a choice, that choice will connect to that urlpatterns
again to find what your a tag is looking on there.
--<a href="{% url 'polls:detail' question.id %}">
- Your a tag connects you to 'polls:detail' and it's called by the 'url'.
As we remember,'polls:detail' calls the detail() in views.py. We put the
{{question.id}} as its argument. And now we can vote. Each choices are
originated on that question.

*URL/polls/{{question.id}}/vote
- After hitting the vote, it connects us to vote() which is happen because of:
--<form action="{% url 'polls:vote' question.id %}" method="post">
- The vote button submits the data(response.POST) in vote() because we
declare it at the form tag and now it calls the vote() and our args is
the response.POST from the detail.html. That response.POST contains the
id of our selected choice in detail.html. In the 1st line of the vote(),
we declare that our function's object is the response.POST and if it is
possible we get the id of the selected choice then save it in varible 
selected_choice. Else, it returns key error because that id is not in the
choices of that question. And if selected_choice is possible, it add 1
to the votes of selected_choice. Next it reverses the redirect you to the
results. But if your response.POST is empty or you don't pick any of them,
it still connects you to the vote but you were stuck to it and there's a
line saying: 'you didn't select a choice'. You were stuck there until you vote.

*URL/polls/{{question.id}}/results
-Simply shows you all the votes for every choice.

3.5. Generic views
-Django has already a built-in views for basic functions like index(),
detail() and result(). Before using them, you must fixed the URLs first:
Before:
urlpatterns = [
    # ex: /polls/
    path('', views.index, name='index'),
    # ex: /polls/5/
    path('<int:question_id>/', views.detail, name='detail'),
    # ex: /polls/5/results/
    path('<int:question_id>/results/', views.results, name='results'),
    # ex: /polls/5/vote/
    path('<int:question_id>/vote/', views.vote, name='vote'),
]

After:
urlpatterns = [
    path('', views.IndexView.as_view(), name='index'),
    path('<int:pk>/', views.DetailView.as_view(), name='detail'),
    path('<int:pk>/results/', views.ResultsView.as_view(), name='results'),
    path('<int:question_id>/vote/', views.vote, name='vote'),
]

-Next, go to your views.py and import:
from django.views import generic

-Then change the ff. function to class:
Before:
def index(request):
    latest_question_list = question.objects.order_by('-pub_date')[:5]
    context = {'latest_question_list': latest_question_list}
    return render(request, 'polls/index.html', context)

def detail(request, question_id):
    myquestion = get_object_or_404(question, pk=question_id)
    return render(request, 'polls/detail.html', {'question': myquestion})

def results(request, question_id):
    myquestion = get_object_or_404(question, pk=question_id)
    return render(request, 'polls/results.html', {'question': myquestion})

After:
class IndexView(generic.ListView):
    template_name = 'polls/index.html'
    context_object_name = 'latest_question_list'

    def get_queryset(self):
        """Return the last five published questions."""
        return Question.objects.order_by('-pub_date')[:5]


class DetailView(generic.DetailView):
    model = Question
    template_name = 'polls/detail.html'


class ResultsView(generic.DetailView):
    model = Question
    template_name = 'polls/results.html'


## PART 5: Automated Testing
Automated Tests -tests that check your code

Strategies of Testing
Test-driven development -doign the tests before writing the code. Before
writing the code, you were thinking of the possible problems and solve it
through coding.

Making our first Test
- Any test codes will automatically run once you run test.py inside your app
name dir(we have polls).
-Here we have our first test:

import datetime

from django.test import TestCase
from django.utils import timezone

from .models import question,was_published_recently

# Create your tests here.
class QuestionModelTests(TestCase):

    def test_was_published_recently_with_future_question(self):
        """
        was_published_recently() returns False for questions whose pub_date
        is in the future.
        """
        time = timezone.now() + datetime.timedelta(days=30)
        future_question = question(pub_date=time)
        self.assertIs(was_published_recently(future_question), False)

    def test_was_published_recently_with_old_question(self):
        """
        was_published_recently() returns False for questions whose pub_date
        is older than 1 day.
        """
        time = timezone.now() - datetime.timedelta(days=1, seconds=1)
        old_question = question(pub_date=time)
        self.assertIs(was_published_recently(old_question), False)

    def test_was_published_recently_with_recent_question(self):
        """
        was_published_recently() returns True for questions whose pub_date
        is within the last day.
        """
        time = timezone.now() - datetime.timedelta(hours=23, minutes=59, seconds=59)
        recent_question = question(pub_date=time)
        self.assertIs(was_published_recently(recent_question), True)

-To run our test, head to terminal, go to the project loction, type:
python3 manage.py test polls

-The Django test client
Django provides a test Client to simulate a user interacting with the code
at the view level. We can use it in tests.py or even in the shell. We will
start again with the shell, where we need to do a couple of things that won’t
be necessary in tests.py. The first is to set up the test environment in the
shell:
$ python manage.py shell

>>> from django.test.utils import setup_test_environment
>>> setup_test_environment()


Improving the Views
We need to amend the get_queryset() method and change it so that it also
checks the date by comparing it with timezone.now(). First we need to add
an import:
from django.utils import timezone

-and then we must amend the get_queryset method like so:
def get_queryset(self):
    """
    Return the last five published questions (not including those set to be
    published in the future).
    """
    return question.objects.filter(
        pub_date__lte=timezone.now()
    ).order_by('-pub_date')[:5]

-Question.objects.filter(pub_date__lte=timezone.now()) returns a queryset
containing Questions whose pub_date is less than or equal to - that is, earlier
than or equal to - timezone.now.

Testing our new view:

Testing the DetailView
-What we have works well; however, even though future questions don’t appear
in the index, users can still reach them if they know or guess the right URL.
So we need to add a similar constraint to DetailView:
Before:
class DetailView(generic.DetailView):
    model = question
    template_name = 'polls/detail.html'

After:
class DetailView(generic.DetailView):
    model = question
    template_name = 'polls/detail.html'

    def get_queryset(self):
        Excludes any questions that aren't published yet."""
        return Question.objects.filter(pub_date__lte=timezone.now())

We should then add some tests, to check that a Question whose pub_date is
in the past can be displayed, and that one with a pub_date in the future is
not:
class QuestionDetailViewTests(TestCase):
    def test_future_question(self):
        """
        The detail view of a question with a pub_date in the future
        returns a 404 not found.
        """
        future_question = create_question(question_text='Future question.', days=5)
        url = reverse('polls:detail', args=(future_question.id,))
        response = self.client.get(url)
        self.assertEqual(response.status_code, 404)

    def test_past_question(self):
        """
        The detail view of a question with a pub_date in the past
        displays the question's text.
        """
        past_question = create_question(question_text='Past Question.', days=-5)
        url = reverse('polls:detail', args=(past_question.id,))
        response = self.client.get(url)
        self.assertContains(response, past_question.question_text)

## REMEMBER:
More tests always better
- Having multiple tests than your code is still better as you keep on upgrading
your app. Just let it there,because some day it might be useful.
- Sometimes tests will need to be updated. Suppose that we amend our views
so that only Questions with Choices are published. In that case, many of
our existing tests will fail - telling us exactly which tests need to be
amended to bring them up to date, so to that extent tests help look after
themselves.At worst, as you continue developing, you might find that you
have some tests that are now redundant. Even that’s not a problem; in testing
redundancy is a good thing.

Good rules-of-thumb include having:
* a separate TestClass for each model or view
* a separate test method for each set of conditions you want to test
* test method names that describe their function



## PART 6: Static Files
- In small projects we can have multiple static file(styles like CSS, etc.) on the
same location of the app but if you do the same on enterprise level, apps it will be
messy. To avoid this kind of problem, django has "django.contrib.staticfiles". What
it goes is it collect all the static files of your apps (and other places you specify)
and then save them all in a one, easy to access, location.

-How does the Django find static files?
Django’s STATICFILES_FINDERS setting contains a list of finders that know how to
discover static files from various sources. One of the defaults is
AppDirectoriesFinder which looks for a “static” subdirectory in each of the
INSTALLED_APPS, like the one in polls we just created. The admin site uses the same
directory structure for its static files.

Styling and Designing your App
a. Make dir inside your app called "static". Inside it, create another dir named
"polls" and inside this dir make a style.css so your loc. should look like this:
polls/static/polls/style.css. This should be the place where our style sheets are.

b. In polls/static/polls/style.css, type the ff code:
li a {
    color: green;
}

c. In polls/templates/polls/index.html, in the upperside, type:
{% load static %}

<link rel="stylesheet" type="text/css" href="{% static 'polls/style.css' %}">
The {% static %} template tag generates the absolute URL of static files. That’s all
you need to do for development. Run your code on your website to see the changes.

Adding a background-image
-Create an images subdirectory in the polls/static/polls/ directory. Inside this
directory, put an image called background.gif. In other words, put your image
background.gif in: polls/static/polls/images/.

Then, add to your stylesheet (polls/static/polls/style.css):
body {
    background: white url("images/background.gif") no-repeat;
}

## REMEMBER:
The {% static %} template tag is not available for use in static files which aren’t
generated by Django, like your stylesheet. You should always use relative paths to
link your static files between each other, because then you can change STATIC_URL
(used by the static template tag to generate its URLs) without having to modify a
bunch of paths in your static files as well.


## PART 7: Django's Admin Site Customizing

7.1. Customizing Your Admin Page to make it easier to add questions and choices
custom the polls/admin.py:
# stacks
# class ChoiceInline(admin.StackedInline):
#     model = choice
#     extra = 3

# the same as the above, difference is its in the same line, unlike the 1st 1, stacked
class ChoiceInline(admin.TabularInline):
    model = choice
    extra = 3

# Question format
class QuestionAdmin(admin.ModelAdmin):
    # The Date Information can hide/show in admin site because of the ['collapse']
    fieldsets = [
        (None,               {'fields': ['question_text']}),
        ('Date information', {'fields': ['pub_date'], 'classes': ['collapse']}),
    ]

    # shows and allows you to add choices while doing the question
    inlines = [ChoiceInline]

    # To view each question w/ its details after clicking the 'Questions' in sidebar
    list_display = ('question_text', 'pub_date', was_published_recently)

    # for filter sidebar via pub_date
    list_filter = ['pub_date']

    # allows you to search
    search_fields = ['question_text']


7.2. Adding side bar filter and search bar in admin site:
--import to polls/models.py:
    from django.contrib import admin

--add to polls/models.py/question:
    @admin.display(
    boolean=True,
    ordering='pub_date',
    description='Published recently?',
    )

--Add in QuestionAdmin:
    # for filter sidebar via pub_date
    list_filter = ['pub_date']

*-The type of filter displayed depends on the type of field you’re filtering on.
Because pub_date is a DateTimeField, Django knows to give appropriate filter options:
“Any date”, “Today”, “Past 7 days”, “This month”, “This year”.

This is shaping up well. Let’s add some search capability in QuestionAdmin:
    # allows you to search
    search_fields = ['question_text']


Customizing your project’s templates

-Create a templates directory in your project directory (the one that contains
manage.py). Templates can live anywhere on your filesystem that Django can access.
(Django runs as whatever user your server runs.) However, keeping your templates
within the project is a good convention to follow. We hade voting-app/settings.py


-Add [BASE_DIR / 'templates'] in 'DIRS' at inside the "TEMPLATES" mysite/settings.py:


TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',

        'DIRS': [],   ### BEFORE
        'DIRS': [BASE_DIR / 'templates'],   ### AFTER

        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

DIRS is a list of filesystem directories to check when loading Django templates; it’s
a search path.


Organizing templates
- Just like the static files, we could have all our templates together, in one big
templates directory, and it would work perfectly well. However, templates that belong 
to a particular application should be placed in that application’s template directory
(e.g. polls/templates) rather than the project’s (templates)