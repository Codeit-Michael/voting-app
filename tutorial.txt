## Part 1: Installing
1. Making a project- choose a dir then type "django-admin startproject
{project name.let's use (mysite)}"

2. Making an app- python3 manage.py startapp {name. lets use (polls)}.

adittional: (Making a simple message 'hello world')
1. Go to polls/views.py and type:
from django.http import HttpResponse

def func1(request):
    return HttpResponse('hello world')

2. Make a file urls.py at polls and type:
from django.urls import path
from . import views

urlpatterns = [
    path('helloworld/',views.func1)
]

3. In mysite/urls.py, follow the ff. for URLConf/URL Configuration

## Part 2: Database setting up, creating first model, and a quick intro to
Django’s automatically-generated admin site
1. Database Setup
- Head to the mysite/settings.py and as you notice it is full of module-level
stuffs. 

1.1 Database dictionary- Django has installed database already which is SQLite.
But you can change your db if you want, other db like mySQL, oracle, etc.
As if you notice the DATABASE dict, it contains 2 items:
* ENGINE (depends what backend and db you are using)
* NAME (contains full path (including filename). The default val contains 
BASE_DIR / 'db.sqlite3' will store that file in project dir)

1.2 Set the TIME_ZONE on your timezone

1.3 INSTALLED_APPS- it has all the app names. It has default apps which is
listed because of the common cases.

1.4 Migrating- to migrate, type 'python3 manage.py migrate'. It creates a 
necessary db tables based on apps present at INSTALLED_APPS and writes
them in your backend/db.

2. Creating Models
Model.py- contains fields(models) and characteristics of your data stored

2.1 Fields(classes)- represented  by every instance inside.
- in our example like the Question field, we have instances;
*question_text- contains models.CharField(maxlength=200), is for character fields
*pub_date- contains models.DateTimeField('date published'), is for datetimes

- On Choices field, we have a ForeignKey() which is to identify relationship
between two fields/classes. Thats why it contains Question class as its
parameter. Its 2nd parameter is 'on_delete = models.CASCADE' means if we 
delete item/s in Question, we also delete its data in Choices

3. Activating Models
3.1 Django apps can be use in different django projects just make sure they
are listed on INSTALLED_APPS at inner django project folder/settings.py.
Just type the dir of apps upto class inside the apps.py.
Format: {dj dir}.apps.{class name} EX: polls.apps.PollsConfig

- After listing it run the code: "python3 manage.py makemigrations polls" to
declare to django that you make some changes on your models (also your database
schema) and you want to save the changes on disk(through migration).

3.2 polls/migrations/0001_initial.py saves the migrations that happened.
They are editable, incase you want to modify something

3.3 command "python3 manage.py sqlmigration polls 0001": takes migration
names and returns their SQL

Note the following:
- The exact output will vary depending on the database you are using. The
example above is generated for PostgreSQL.
- Table names are automatically generated by combining the name of the app
(polls) and the lowercase name of the model – question and choice. (You can override this behavior.)

- Primary keys (IDs) are added automatically. (You can override this, too.)

- By convention, Django appends "_id" to the foreign key field name. (Yes,
you can override this, as well.)

- The foreign key relationship is made explicit by a FOREIGN KEY constraint. Don’t worry about the DEFERRABLE parts; it’s telling PostgreSQL to not enforce the foreign key until the end of the transaction.

- It’s tailored to the database you’re using, so database-specific field
types such as auto_increment (MySQL), serial (PostgreSQL), or integer primary key autoincrement (SQLite) are handled for you automatically. Same goes for the quoting of field names – e.g., using double quotes or single quotes.

- The sqlmigrate command doesn’t actually run the migration on your db - instead,
it prints it to the screen so that you can see what SQL Django
thinks is required. It’s useful for checking what Django is going to do or
if you have database administrators who require SQL scripts for changes.

3.4 python manage.py check; this checks for any problems in your project
without making migrations or touching the database.


3.5 3 steps in making model changes
- Change your models (in models.py).
- 'python manage.py makemigrations' to create migrations for those changes
- 'python manage.py migrate' to apply those changes to the database.

* Migrations are very powerful and let you change your models over time, as
you develop your project, without the need to delete your database or tables
and make new ones - it specializes in upgrading your database live, without
losing data.
